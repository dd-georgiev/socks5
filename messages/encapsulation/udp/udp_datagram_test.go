package udp

import (
	"reflect"
	"socks5_server/messages/shared"
	"strings"
	"testing"
)

func Test_UDPDatagram_Deserialization(t *testing.T) {
	request := [][]byte{
		{0x00, 0x00, 0x00, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF, 0x00},
		{0x00, 0x00, 0x7F, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF, 0x00},
		{0x00, 0x00, 0xFF, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF, 0x00},
		{0x00, 0x00, 0xFF, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50, 0xFF},
		{0x00, 0x00, 0x7F, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50, 0xFF, 0x01, 0x02, 0x03, 0x03},
		{0x00, 0x00, 0x58, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50, 0xFF, 0x01, 0x02, 0x03, 0x03},
		{0x00, 0x00, 0x00, shared.ATYP_FQDN, 0x0b, 0x69, 0x66, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x6d, 0x65, 0x00, 0x50, 0xFF, 0x01, 0x02, 0x03},
	}
	expected := []UDPDatagram{
		{Frag: 0, DST_ADDR: shared.DstAddr{Value: "2001:0000:130f:0000:0000:09c0:876a:130b", Type: shared.ATYP_IPV6}, DST_PORT: 65535, DATA: []byte{0x00}},
		{Frag: 127, DST_ADDR: shared.DstAddr{Value: "2001:0000:130f:0000:0000:09c0:876a:130b", Type: shared.ATYP_IPV6}, DST_PORT: 65535, DATA: []byte{0x00}},
		{Frag: 255, DST_ADDR: shared.DstAddr{Value: "2001:0000:130f:0000:0000:09c0:876a:130b", Type: shared.ATYP_IPV6}, DST_PORT: 65535, DATA: []byte{0x00}},
		{Frag: 255, DST_ADDR: shared.DstAddr{Value: "127.0.0.1", Type: shared.ATYP_IPV4}, DST_PORT: 80, DATA: []byte{0xFF}},
		{Frag: 127, DST_ADDR: shared.DstAddr{Value: "127.0.0.1", Type: shared.ATYP_IPV4}, DST_PORT: 80, DATA: []byte{0xFF, 0x01, 0x02, 0x03, 0x03}},
		{Frag: 88, DST_ADDR: shared.DstAddr{Value: "127.0.0.1", Type: shared.ATYP_IPV4}, DST_PORT: 80, DATA: []byte{0xFF, 0x01, 0x02, 0x03, 0x03}},
		{Frag: 0, DST_ADDR: shared.DstAddr{Value: "ifconfig.me", Type: shared.ATYP_FQDN}, DST_PORT: 80, DATA: []byte{0xFF, 0x01, 0x02, 0x03}},
	}

	for i, req := range request {
		datagram := UDPDatagram{}
		err := datagram.Deserialize(req)
		if err != nil {
			t.Fatalf("%v", err)
		}
		if datagram.Frag != expected[i].Frag {
			t.Fatalf("Frag mismatch, expected %v, got %v", expected[i].Frag, datagram.Frag)
		}
		if datagram.DST_ADDR.Value != expected[i].DST_ADDR.Value {
			t.Fatalf("Mismatched dst addr value expected %v, got %v", expected[i].DST_ADDR.Value, datagram.DST_ADDR.Value)
		}
		if datagram.DST_ADDR.Type != expected[i].DST_ADDR.Type {
			t.Fatalf("Mismatch dst addr type expected %v, got %v", expected[i].DST_ADDR.Type, datagram.DST_ADDR.Type)
		}
		if datagram.DST_PORT != expected[i].DST_PORT {
			t.Fatalf("Mismatched dst port expected %vgot %v", expected[i].DST_PORT, datagram.DST_PORT)
		}
		if reflect.DeepEqual(datagram.DATA, expected[i].DATA) != true {
			t.Fatalf("Mismatched data expected %v, got %v", expected[i].DATA, datagram.DATA)
		}
	}
}

func Test_UDPDatagram_Deserialize_with_invalid_RSV(t *testing.T) {
	request := [][]byte{
		{0x00, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF, 0x00},
		{0x00, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50, 0xFF},
		{0x00, shared.ATYP_FQDN, 0x0b, 0x69, 0x66, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x6d, 0x65, 0x00, 0x50, 0xFF, 0x01, 0x02, 0x03},
	}
	for i := 0; i < 256; i++ {
		for j := 0; j < 256; j++ {
			if j == 0 && i == 0 { // this is valid rsv
				continue
			}
			for _, reqWithoutRsv := range request {
				invalidReq := append([]byte{byte(i), byte(j)}, reqWithoutRsv...)
				dgram := UDPDatagram{}
				err := dgram.Deserialize(invalidReq)
				if err == nil {
					t.Fatalf("%v: expected error but got nil", invalidReq)
				}
			}
		}
	}
}
func Test_UDPDatagram_ToBytes(t *testing.T) {
	datagrams := []UDPDatagram{
		{Frag: 0, DST_ADDR: shared.DstAddr{Value: "2001:0000:130f:0000:0000:09c0:876a:130b", Type: shared.ATYP_IPV6}, DST_PORT: 65535, DATA: []byte{0x00}},
		{Frag: 127, DST_ADDR: shared.DstAddr{Value: "2001:0000:130f:0000:0000:09c0:876a:130b", Type: shared.ATYP_IPV6}, DST_PORT: 65535, DATA: []byte{0x00}},
		{Frag: 255, DST_ADDR: shared.DstAddr{Value: "2001:0000:130f:0000:0000:09c0:876a:130b", Type: shared.ATYP_IPV6}, DST_PORT: 65535, DATA: []byte{0x00}},
		{Frag: 255, DST_ADDR: shared.DstAddr{Value: "127.0.0.1", Type: shared.ATYP_IPV4}, DST_PORT: 80, DATA: []byte{0xFF}},
		{Frag: 127, DST_ADDR: shared.DstAddr{Value: "127.0.0.1", Type: shared.ATYP_IPV4}, DST_PORT: 80, DATA: []byte{0xFF, 0x01, 0x02, 0x03, 0x03}},
		{Frag: 88, DST_ADDR: shared.DstAddr{Value: "127.0.0.1", Type: shared.ATYP_IPV4}, DST_PORT: 80, DATA: []byte{0xFF, 0x01, 0x02, 0x03, 0x03}},
		{Frag: 0, DST_ADDR: shared.DstAddr{Value: "ifconfig.me", Type: shared.ATYP_FQDN}, DST_PORT: 80, DATA: []byte{0xFF, 0x01, 0x02, 0x03}},
	}
	expected := [][]byte{
		{0x00, 0x00, 0x00, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF, 0x00},
		{0x00, 0x00, 0x7F, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF, 0x00},
		{0x00, 0x00, 0xFF, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF, 0x00},
		{0x00, 0x00, 0xFF, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50, 0xFF},
		{0x00, 0x00, 0x7F, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50, 0xFF, 0x01, 0x02, 0x03, 0x03},
		{0x00, 0x00, 0x58, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50, 0xFF, 0x01, 0x02, 0x03, 0x03},
		{0x00, 0x00, 0x00, shared.ATYP_FQDN, 0x0b, 0x69, 0x66, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x6d, 0x65, 0x00, 0x50, 0xFF, 0x01, 0x02, 0x03},
	}
	for i, datagram := range datagrams {
		bytes, err := datagram.ToBytes()
		if err != nil {
			t.Fatalf("%v", err)
		}
		if reflect.DeepEqual(bytes, expected[i]) != true {
			t.Fatalf("%v: expected %v, got %v", datagram, expected[i], bytes)
		}
	}
}
func Fuzz_UDPDatagram_Deserialize(f *testing.F) {
	f.Add([]byte{0x00, 0x00, shared.ATYP_IPV6, 0x20, 0x01, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0xC0, 0x87, 0x6a, 0x13, 0x0b, 0xFF, 0xFF})
	f.Add([]byte{0x00, 0x00, shared.ATYP_IPV4, 0x7f, 0x00, 0x00, 0x01, 0x00, 0x50})
	f.Add([]byte{0x00, 0x00, shared.ATYP_FQDN, 0x0b, 0x69, 0x66, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x6d, 0x65, 0x00, 0x50})
	f.Fuzz(func(t *testing.T, data []byte) {
		datagram := UDPDatagram{}
		err := datagram.Deserialize(data)
		if err != nil && !isKnownError(err) {
			t.Fatalf("Error: %v, Data: %v", err, data)
		}
	})
}

func isKnownError(err error) bool {
	return strings.Contains(err.Error(), "Unknown auth method") ||
		strings.Contains(err.Error(), "Message is malformed") ||
		strings.Contains(err.Error(), "Invalid reserved field") ||
		strings.Contains(err.Error(), "Invalid Atyp")
}
