package server

import (
	"errors"
	"fmt"
	"net"
	"slices"
	"socks5_server/messages/requests/available_auth_methods"
	"socks5_server/messages/requests/command_request"
	"socks5_server/messages/responses/accept_auth_method"
	"socks5_server/messages/responses/command_response"
	"socks5_server/messages/shared"
	"socks5_server/server/proxies"
)

type Socks5Server struct {
	Listener net.Listener
	sessions []Socks5Session
}

// not thread safe
func (srv *Socks5Server) addSession(session Socks5Session) int {
	srv.sessions = append(srv.sessions, session)
	return len(srv.sessions) - 1
}
func (s *Socks5Server) Start() {

	conn, err := s.Listener.Accept()
	if err != nil {
		return
	}
	session := Socks5Session{conn: conn, state: WaitingForAuthenticationMethods}
	id := s.addSession(session)
	session.index = id
	//go session.handler()
	msg := make([]byte, 1024)
	n, err := session.conn.Read(msg)

	if err != nil {
		return
	}
	session.pickAuthenticationMethod(msg, n)

}

type SessionState int

const (
	WaitingForAuthenticationMethods SessionState = 0
	PendingAuthentication           SessionState = 10
	Authenticated                   SessionState = 20
	Proxying                        SessionState = 30
	Errored                         SessionState = 40
)

type Socks5Session struct {
	conn  net.Conn
	state SessionState
	index int
	err   error
}

func (session *Socks5Session) setError(err error) {
	session.err = err
	session.state = Errored
}

func (session *Socks5Session) handler() {
	msg := make([]byte, 1024)
	n, err := session.conn.Read(msg)

	if err != nil {
		return
	}
	session.pickAuthenticationMethod(msg, n)
}
func (session *Socks5Session) pickAuthenticationMethod(authMethodCandidate []byte, n int) {
	session.state = PendingAuthentication
	authMethods := available_auth_methods.AvailableAuthMethods{}
	err := authMethods.Deserialize(authMethodCandidate[:n])
	if err != nil {
		session.setError(err)
	}
	msg := accept_auth_method.AcceptAuthMethod{}
	if slices.Contains(authMethods.Methods(), shared.NoAuthRequired) {
		err := msg.SetMethod(shared.NoAuthRequired)
		if err != nil {
			session.setError(err)
		}
		return
	}
	err = msg.SetMethod(shared.NoAcceptableMethods)
	if err != nil {
		session.setError(err)
	}
	session.conn.Write(msg.ToBytes())
	session.state = Authenticated
}
func (session *Socks5Session) waitForCommand() {
	commandCandidate := make([]byte, 128)
	n, err := session.conn.Read(commandCandidate)
	if err != nil {
		session.setError(err)
	}
	cmd := command_request.CommandRequest{}
	err = cmd.Deserialize(commandCandidate[:n])
	if err != nil {
		session.setError(err)
	}
	if cmd.CMD != shared.CONNECT {
		resp := command_response.CommandResponse{}
		resp.Status = command_response.CommandNotSupported
		bytes, err := resp.ToBytes()
		if err != nil {
			session.setError(err)
		}
		session.conn.Write(bytes)
		session.setError(errors.New("unsupported command"))
		return
	}
	// start proxy
	proxyErrors := make(chan error)
	remoteAddr := fmt.Sprintf("%s:%d", cmd.DST_ADDR.Value, cmd.DST_PORT)
	proxy, err := proxies.NewConnectProxy(remoteAddr, session.conn)
	if err != nil {
		session.setError(err)
	}
	err = proxy.Start(proxyErrors)
	if err != nil {
		session.setError(err)
	}
	go session.proxyErrorHandler(proxyErrors, proxy)
	resp := command_response.CommandResponse{}
	resp.Status = command_response.Success
	bytes, err := resp.ToBytes()
	if err != nil {
		session.setError(err)
	}
	session.conn.Write(bytes)
	session.state = Proxying
}

func (session *Socks5Session) proxyErrorHandler(errors chan error, proxy *proxies.ConnectProxy) {
	err := <-errors
	session.setError(err)
	proxy.Stop()
}





////

package server

import (
	"fmt"
	"log"
	"net"
	"socks5_server/messages/responses/accept_auth_method"
	"socks5_server/messages/responses/command_response"
	"socks5_server/messages/shared"
)

type Session struct {
	state uint16
}

func Start(listener net.Listener) {
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Fatal(err)
		}
		session := Session{state: 0}
		go handler(conn, session)
	}
}

func handler(conn net.Conn, session Session) {
	for {
		msg := make([]byte, 1024)
		n, err := conn.Read(msg)
		if err != nil {
			log.Fatal(err)
		}
		fmt.Print(string(msg[:n]))
		if session.state == 1 {
			cmd := command_response.CommandResponse{}
			cmd.Status = command_response.Success
			cmd.BND_PORT = 0
			cmd.BND_ADDR = shared.DstAddr{Value: "0.0.0.0", Type: shared.ATYP_IPV4}
			resp, _ := cmd.ToBytes()
			conn.Write(resp)
			session.state = 2
		}
		if session.state == 0 {
			rsp := accept_auth_method.AcceptAuthMethod{}
			rsp.SetMethod(0)
			conn.Write(rsp.ToBytes())
			session.state = 1
		}

	}
}
