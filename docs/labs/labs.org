* Introduction
* Labs
** Lab 1
*** Overview
The goal of this exercise is to explore the protocol by monitoring the network traffic from client, through proxy server and to mocked TCP/UDP server. In the end we will have a series of pcaps outlining the different SOCKS5 commands. Authentication and traffic rules(i.e. the proxy server allowing/denying certain requests is out of scope.
*** Tooling
1. [[https://github.com/v-byte-cpu/wirez][Wirez]] is a tool for redirecting TCP and UDP traffic to SOCKS5 proxy. It is written in Golang. It supports the `CONNECT` and `UDP ASSOCIATE` commands
2. [[https://linux.die.net/man/1/socat][Socat]] is a tool for relaying information between two bidirectional byte streams. It supports the `BIND` command
3. [[https://www.wireshark.org/][Wireshark]] is tool for capturing and analyzing network traffic.
4. [[https://www.inet.no/dante/][Dante]] is a free SOCKS5 server
5. [[https://linux.die.net/man/1/nc][netcat]] is tool for working with TCP and UDP connections.
*** Concepts
**** SOCKS5 commands
In [[https://datatracker.ietf.org/doc/html/rfc1928][RFC1928]], the following commands are outlined:
+ CONNECT - This is the basic forwarding of TCP segments from the client to the server.
+ BIND - The BIND command is used in scenarios, where the server will attempt to connect back to the client. A typical usage of BIND is for P2P network protocols or [[https://stackoverflow.com/questions/25092819/when-should-an-ftp-server-connect-to-ftp-client-after-port-command][FTP]]. The ~BIND~ command is send after ~CONNECT~ command
+ UDP_ASSOCIATE - The proxy is relaying UDP datagrams to server and the responses from the server are relayed back to the client. The connection is started via TCP, but later on the proxy server must offer an UDP listener, on which datagrams with specific format are being sent.
**** SOCKS5 connection flow

In [[https://datatracker.ietf.org/doc/html/rfc1928][RFC1928]], the connection flow is outlined as follows:
1. The ~client~ sends a message containing the available authentication methods
2. The ~server~ picks authentication method, or returns ~NO ACCEPTED METHODS~
3. If the response is ~NO ACCEPTED METHODS~ the ~client~ terminates the connection
4. If the response contains a desired authentication method, the ~client~ and the ~server~ enter a method-dependent sub-negotiation
5. Once the authentication is completed, the ~client~ sends a command - either ~CONNECT~, ~BIND~ or ~UDP_ASSOCIATE~
6. The server evaluates the requests and returns a response, either indicating success or failure.
7. In case of success, the proxying starts.
[[./img/socks5_connection_flowchart.png]]
**** SOCKS5 messages formats
The messages of SOCKS5 can be roughly divided in ~requests~ and ~responses~. Every message starts with a field called ~VER~, which in SOCKS5 is always the value of 5 (or 0x05). At the end of this lab, we will have an example of each message which the protocol provides. [[https://datatracker.ietf.org/doc/html/rfc1928][RFC1928]] provides some examples.
*** Experiments
**** Prerequisites
***** Network setup
*CONNECT and UDP_ASSOCIATE commands*
[[./img/lab_1_network_setup.png]]
*BIND command*
[[./img/lab_1_network_setup_bind_command.png]]

***** Compiling wirez
As [[https://github.com/v-byte-cpu/wirez][Wirez]] doesn't provide ready to use binary, we must compile it. The instructions below are for Linux. You can compile the program by following the instructions in the repository.
1. Install go 1.20
#+BEGIN_SRC bash
$ go install golang.org/dl/go1.20.9@latest
$ go1.20.9 download
#+END_SRC
2. Clone the repository
#+BEGIN_SRC bash
$ git clone https://github.com/v-byte-cpu/wirez.git
#+END_SRC
3. Compile
#+BEGIN_SRC bash
$ cd wirez
$ go build
#+END_SRC 
***** Starting Dante on local machine with Docker
Running [[https://www.inet.no/dante/][Dante]] locally with Docker is a convenient way, as the setup doesn't focus on the specifics of the proxy server. 
1. [[https://docs.docker.com/engine/install/][Install docker]]
2. Pull the following image: ~wernight/dante~
3. To start the container and bind port ~1080~ to it run ~docker run -p 1080:1080 wernight/dante~
4. If everything was successful so far, you must have the following log line:
#+BEGIN_SRC
Jan 24 19:42:40 (1737747760.895891) sockd[7]: info: Dante/server[1/1] v1.4.2 running
#+END_SRC
***** Installing other tools
The rest of the tooling (~netcat~, ~socat~, and ~Wireshark~) is widely available, consult official guidelines for your platform.
**** Exploring the CONNECT command
***** Setting up mock TCP server
The following command can be used to start a mock TCP server on port 8888:
#+BEGIN_SRC bash
$ nc -l 8888
#+END_SRC
***** Connecting to the TCP server via netcat and wirez
We can connect to the server from the previous point using the following command:
#+BEGIN_SRC
./wirez run -F PROXY_IP:PROXY_PORT -- nc SERVER_IP SERVER_PORT
# Example: ./wirez run -F 127.0.0.1:1080 -- nc 148.113.191.22 8888
#+END_SRC
***** Analyzing the traffic
1. Message send from the client on connection initialization
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 43992, Dst Port: 1080, Seq: 1, Ack: 1, Len: 3
Socks Protocol
    Version: 5
    Client Authentication Methods
        Authentication Method Count: 1
        Method[0]: 0 (No authentication) 
#+END_SRC
2. Message send from the server picking an auth method
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 43992, Dst Port: 1080, Seq: 1, Ack: 1, Len: 3
Socks Protocol
    Version: 5
    Accepted Auth Method: 0x0 (No authentication)

#+END_SRC
3. Client requesting ~connect~ command
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 43992, Dst Port: 1080, Seq: 4, Ack: 3, Len: 10
Socks Protocol
    Version: 5
    Command: Connect (1)
    Reserved: 0
    Address Type: IPv4 (1)
    Remote Address: 148.113.191.22
    Port: 8888
#+END_SRC
4. Server responding to ~CONNECT~ command
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 1080, Dst Port: 43992, Seq: 3, Ack: 14, Len: 10
Socks Protocol
    Version: 5
    Results(V5): Succeeded (0)
    Reserved: 0
    Address Type: IPv4 (1)
    Remote Address: 172.17.0.2
    Port: 43992
#+END_SRC
5. Client opening connection to server via proxy
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 43992, Dst Port: 1080, Seq: 14, Ack: 13, Len: 1
Socks Protocol
    [Version: 5]
    [Command: Connect (1)]
    [Remote Address: 148.113.191.22]
    [Remote Port: 8888]
    TCP payload (1 byte)
Data (1 byte)

0000  0a                                                .
    Data: 0a
    [Length: 1]
#+END_SRC
6. Client sending data to server via proxy
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 43992, Dst Port: 1080, Seq: 15, Ack: 13, Len: 5
Socks Protocol
    [Version: 5]
    [Command: Connect (1)]
    [Remote Address: 148.113.191.22]
    [Remote Port: 8888]
    TCP payload (5 bytes)
Data (5 bytes)

0000  74 65 73 74 0a                                    test.
    Data: 746573740a
    [Length: 5]
#+END_SRC
7. Proxy server sending response from server to client
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 1080, Dst Port: 43992, Seq: 13, Ack: 20, Len: 5
Socks Protocol
    [Version: 5]
    [Command: Connect (1)]
    [Remote Address: 148.113.191.22]
    [Remote Port: 8888]
    TCP payload (5 bytes)
Data (5 bytes)

0000  74 65 73 74 0a                                    test.
    Data: 746573740a
    [Length: 5]
#+END_SRC
**** Exploring the BIND command
***** Setting up mock TCP Server
#+BEGIN_SRC
  $ docker run -it --entrypoint=/bin/sh subfuzion/netcat
  $ nc -l 8888
#+END_SRC
***** Connecting to the TCP server via netcat and socat - issuing CONNECT command
#+BEGIN_SRC
# Get TCP server IP
$  IP=`docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -q -f "ancestor=subfuzion/netcat")`
$  socat --experimental - SOCKS5:127.0.0.1:1080:"$IP":8888
#+END_SRC
***** Connecting from the TCP server to the client via the proxy - issuing BIND command
#+BEGIN_SRC
# Get TCP server IP
$ IP=`docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(docker ps -q -f "ancestor=subfuzion/netcat")`
$ socat --experimental - SOCKS5-LISTEN:127.0.0.1:1080:"$IP":8888
#+END_SRC
***** Connecting from the mock TCP server to the client via the proxy
#+BEGIN_SRC
$ CONTAINER_ID=(docker ps -q -f "ancestor=subfuzion/netcat)
$ docker exec -it "$CONTAINER_ID" sh
$ nc PROXY_IP PROXY_PORT_FROM_BIND_RESPONSE
#+END_SRC
*note: the PROXY_PORT_FROM_BIND_RESPONSE is obtained from analyzing the response with Wireshark*
***** Analyzing the traffic
*notes:*
*1. The messages which overlap with the ~CONNECT~ command are omitted here*
*2. It appears that the data proxied from the server, to the client (i.e. data send to the binded port) is not encapsulated in protocol-specific message*

1. Bind Request
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 1080, Dst Port: 40264, Seq: 3, Ack: 14, Len: 10
Socks Protocol
    Version: 5
    Results(V5): Succeeded (0)
    Reserved: 0
    Address Type: IPv4 (1)
    Remote Address: 172.17.0.2
    Port: 59073
#+END_SRC
2. Bind response
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 1080, Dst Port: 40264, Seq: 13, Ack: 14, Len: 10
Socks Protocol
    Version: 5
    Results(V5): Succeeded (0)
    Reserved: 0
    Address Type: IPv4 (1)
    Remote Address: 172.17.0.3
    Remote Host Port: 57608
#+END_SRC
**** Exploring the UDP_ASSOCIATE command
***** Setting up mock UDP server
#+BEGIN_SRC
$ nc -lu 8888
#+END_SRC
***** Connecting to the mock UDP server via wirez and netcat
#+BEGIN_SRC
$ ./wirez run -F 127.0.0.1:1080 -- nc -u 148.113.191.22 8888
#+END_SRC

***** Analyzing the traffic
*Note: The UDP request to the server doesn't contain any socks5 specific encapsulatin
1. ~UDP_ASSOCIATE~ command request
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 39302, Dst Port: 1080, Seq: 4, Ack: 3, Len: 10
Socks Protocol
    Version: 5
    Command: UdpAssociate (3)
    Reserved: 0
    Address Type: IPv4 (1)
    Remote Address: 0.0.0.0
    Port: 0
#+END_SRC
2. ~UDP_ASSOCIATE~ command response
#+BEGIN_SRC
Transmission Control Protocol, Src Port: 1080, Dst Port: 39302, Seq: 3, Ack: 14, Len: 10
Socks Protocol
    Version: 5
    Results(V5): Succeeded (0)
    Reserved: 0
    Address Type: IPv4 (1)
    Remote Address: 172.17.0.2
    Port: 36277
#+END_SRC
3. Transfer from client to server via proxy
#+BEGIN_SRC
User Datagram Protocol, Src Port: 33010, Dst Port: 36277
Data (15 bytes)

0000  00 00 00 01 94 71 bf 16 22 b8 74 65 73 74 0a      .....q..".test.
    Data: 000000019471bf1622b8746573740a
    [Length: 15]

#+END_SRC
4. Transfering server response to client via proxy
#+BEGIN_SRC
User Datagram Protocol, Src Port: 36277, Dst Port: 33010
Data (15 bytes)

0000  00 00 00 01 94 71 bf 16 22 b8 74 65 73 74 0a      .....q..".test.
    Data: 000000019471bf1622b8746573740a
    [Length: 15]

#+END_SRC
*** Conclusion
**** Observed messages

